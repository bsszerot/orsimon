#--
#-- ВНИМАНИМЕ Настоящий программный код является частью коммерческого программного продукта ОрСиМОН БЕССТ (С) Sergey S. Belonin Все права защищены.
#-- Использование настоящего кода без заключения письменного лицензионного соглашения с правообладателем или правомочным сублицензиаром ЗАПРЕЩЕНО
#-- ATTENTION This procedure are part of commercial software product OrSiMON BESST (C) Sergey S. Belonin All rights reserved
#-- Before use this code you must sign license agreement with owner or sublicensear
#--


#$event_num{db file sequential read} = 1 ;
#$event_desc{db_file_sequential_read} = "Пример описания db file sequential read" ;

$event_desc{'db_file_async_I/O_submit'} = "Событие ожидания <B>db file async I/O submit</B><P></P>" ;
$event_desc{'log_file_parallel_write'} = "Событие ожидания <B>log file parallel write</B><P></P>" ;
$event_desc{'control_file_parallel_write'} = "Событие ожидания <B>control file parallel write</B><P></P>" ;
$event_desc{'log_file_sync'} = "Событие ожидания <B>log_file_sync</B><P></P>" ;
$event_desc{'os_thread_startup'} = "Событие ожидания <B>os thread startup</B><P></P>" ;
$event_desc{'Log_archive_I/O'} = "Событие ожидания <B>Log archive I/O</B><P></P>" ;
$event_desc{'SQL*Net_message_from_dblink'} = "Событие ожидания <B>SQL*Net message from dblink</B><P></P>" ;
$event_desc{'log_file_switch_completion'} = "Событие ожидания <B>log file switch completion</B><P></P>" ;
$event_desc{'db_file_parallel_read'} = "Событие ожидания <B>db file parallel read</B><P></P>" ;
$event_desc{'log_file_sequential_read'} = "Событие ожидания <B>log file sequential read</B><P></P>" ;
$event_desc{'control_file_sequential_read'} = "Событие ожидания <B>control file sequential read</B><P></P>" ;
$event_desc{'enq:_CR_-_block_range_reuse_ckpt'} = "Событие ожидания <B>enq: CR - block range reuse ckpt</B><P></P>" ;
$event_desc{'SQL*Net_more_data_to_client'} = "Событие ожидания <B>SQL*Net more data to client</B><P></P>" ;
$event_desc{'Disk_file_operations_I/O'} = "Событие ожидания <B>Disk file operations I/O</B><P></P>" ;
$event_desc{ADR_block_file_read} = "Событие ожидания <B>ADR block file read</B><P></P>" ;
$event_desc{'SGA:_allocation_forcing_component_growth'} = "Событие ожидания <B>SGA: allocation forcing component growth</B><P></P>" ;
$event_desc{'latch:_shared_pool'} = "Событие ожидания <B>latch: shared pool</B><P></P>" ;

# ================================================================================================
# события памяти SGA - детализация - кеш буферов
# ================================================================================================
$event_desc{'buffer_busy_waits'} = "Событие ожидания <B>buffer busy waits</B>
<P>[описание готовилось для версии 9i]<BR><BR> Это событие отражает конкуренцию за какой либо блок в одном из кэшей. Статистику по классам буферов (основные классы data block,
 segment header, undo header, and
 undo block) можно получить из V\$WAITSTAT, а из V\$SESSION_WAIT можно получить данные о файле (P1) и блоке в нем (параметр P2), по которым можно вычислить сегмент и его тип:
 <BR><BR>SELECT class, count FROM V\$WAITSTAT WHERE count > 0 ORDER BY count DESC;
 <BR>SELECT segment_owner, segment_name FROM DBA_EXTENTS WHERE file_id = <p1> AND <p2> BETWEEN block_id AND block_id + blocks - 1;
 <BR><BR>Реакция на событие зависит от класса блоков:
 <UL>
 <LI>заголовок сегмента (segment header) - скорее всего связан с утилизацией FREELIST. По возможности необходимо перевести управление сегментами в автоматический режим,
     что исключит необходимость установки параметров PCTUSED, FREELISTS, and FREELIST GROUPS. Freelist - список свободных (свободного места больше PCTFREE) блоков в экстентах
     некоторого сегмента, определяется модификатором параметров хранения FREELISTS, по умолчанию один. Методом решения является увеличение количества freelists, а при
     недостаточности - введение групп списков (даже для одного экземпляра, в RAC у каждого экземпляра должна быть своя группа). Текущие настройки для сегмента можно увидеть
     запросом:
     <BR>SELECT SEGMENT_NAME, FREELISTS FROM DBA_SEGMENTS WHERE SEGMENT_NAME = segment name AND SEGMENT_TYPE = segment type;</LI>
 <LI>блок данных (data block) - для таблицы или индекса необходимо исключить использование неселективных индексов, проверить нагруженные индексы (когда вставка инициируется
   многими процессами, например, последовательности), перейти на автоматическое управление сегментами или увеличить количество freelist</LI>
 <LI> заголовок отмены (undo header) - если не используется автоматическое управление пространством отмены, нужно увеличить количество сегментов отката</LI>
 <LI> блок отмены (undo block) - если не используется автоматическое управление пространством отмены, нужно увеличить размер сегментов отката</LI>
 </UL>
 </P>" ;

$event_desc{'free_buffer_waits'} = "Событие ожидания <B>free buffer waits</B>
<P>[описание готовилось для версии 9i]<BR><BR> Возникает, когда серверный процесс не может найти свободный буфер и запрашивает сброс процессом грязных (в которых были изменены
 данные) буферов на диск. Причины -
 медленный I/O, ожидание ресурсов (например, защелки), слишком маленький буфер - процесс DBRW не успевает обработать или же слишком большой - один DBRW не справляется</P>
<P>При частом возникновении нужно отследить события ожидание, связанные с DBRW</P>
<P>Если это записи, смотреть в V\$FILESTAT и статистику ОС на предмет допустимости нагрузки и последующая оптимизация или расширение подсистемы ввода/вывода</P>
<P>Если малый кеш - коэффициент попадания будет низкий, а новый оптимальный размер можно подсмотреть в V\$DB_CACHE_ADVICE. Если размер кеша адекватен, но проблема остается -
 можно перевести DBRW в асинхронный режим или активировать несколько DBRW параметром DB_WRITER_PROCESSES (количество сканеров LRU списка кеша, опция предпочтительна на SMP
 системах с асинхронным I/O) или параметром DBWR_IO_SLAVES (непосредственно дочки, осуществляющие ввод/вывод, допустимо при одном CPU или для эмуляции асинхронного I/O,
 который предпочтителен)</P>
<P>При отсутствии поддержки асинхронного I/O его необходимо отключить в движке DISK_ASYNCH_IO = false. Также нужно использовать только один из параметров DB_WRITER_PROCESSES
 и DBWR_IO_SLAVES</P>" ;

# ================================================================================================
# события памяти SGA - детализация - буфер оперативных журналов
# ================================================================================================
$event_desc{'log_buffer_space'} = "Событие ожидания <B>log buffer space</B>
<P>[описание готовилось для версии 9i]<BR><BR> Cобытие подразумевает ожидание серверным процессом свободного места в журнальном буфере, по причине наполнения буфера настолько
 быстрого, что LGWR не успевает записывать
 данные в redo log. Если подсистема воода/вывода для оперативных журналов адекватна, то необходимо увеличить размер журнального буффера до момента, пока событие станет редким
 или перестанет появляться, до этого выверять и тюнить подсистему I/O</P>" ;

# ================================================================================================
# ввод/вывод оперативных журналов
# ================================================================================================
$event_desc{'log_file_switch_(archiving_needed)'} = "Событие ожидания <B>log file switch (archiving needed)</B>
<P>[описание готовилось для версии 9i]<BR><BR> группа из двух событий - log file switch (archiving needed) и log file switch (checkpoint incomplete) - подразумевает, что LGRW
 не может переключиться на следующий журнал, и все COMMIT запросы ожидают этого переключения</P>
<P>При переключении оперативных журналов возможна ситуация, когда журнал, на который происходит переключение, ещё не заархивирован. В этом случае переключение притормаживается
 до того момента, пока ARCxx не заархивирует соответствующий журнал</P>
<P>Для события log file switch (archiving needed) необходимо выявить причину, по которой архивер не может записать архивную информацию в разумные сроки. Причины могут быть -
 нехватка места для архивного журнала, архивер не может читать из оперативного журнала достаточно быстро (связано с LGWR), архивер не может отписывать достаточно быстро (в
 этом случае нужно проверить пропускную способность целевого хранилища, потом - его заполненность, потом - увеличивать количество процессов архивирования ARCHn)</P>" ;

$event_desc{'log_file_switch_(checkpoint_incomplete)'} = "Событие ожидания <B>log file switch (checkpoint incomplete)</B>
<P>[описание готовилось для версии 9i]<BR><BR> Группа из двух событий - log file switch (archiving needed) и log file switch (checkpoint incomplete) - подразумевает, что LGRW
 не может переключиться на следующий журнал, и все COMMIT запросы ожидают этого переключения</P>
<P>При переключении оперативных журналов возможна ситуация, когда данные того журнала, на который происходит переключение, ещё не сброшены в файлы БД. В этом случае
 переключение притормаживается до того момента, пока DBWRxx не запишет соответствующие данные в файлы данных БД, то есть не отработает контрольную точку, порождённую
 предыдущим переключением этого же журнала</P>
<P>Важно помнить, что статус журнала \"активный\" устанавливается сразу после переключения на новый журнал, и снимается тогда, когда DBWRxx полностью сбросит грязные буфера,
 соответствующие контрольной точке, порождённой переключением журнала, в файлы БД</P>
<P>Также является симптомом недостаточного размера групп оперативных журналов, полезно проверить частоту переключения журналов. Рекомендованное вендором значение - одно
 переключение в 20 минут. Если со скоростью переключения всё в порядке, то это симптом медленных устройств физического ввода/вывода или неэффективной архитектуры физического
 ввода/вывода</P> 
<P>Для события log file switch (checkpoint incomplete) необходимо выявить причины, по которым DBWR отрабатывает медленно - это или медленное хранилище, или неоптимальное
 распределение данных в хранилище. Если не DBWR - причиной может быть малое количество журнальных групп или малый размер оперативных журналов, когда цикл переключения
 оперативных журналов проходится быстрее, чем DBWR отрабатывает запись данных по контрольной точке - в этом случае нужно учеличить количество журнальных групп и/или размер
 групп соответственно</P>" ;

# ================================================================================================
# прямой ввод/вывод минуя SGA
# ================================================================================================
$event_desc{'direct_path_read'} = "Событие ожидания <B>direct path read</B>
<P>[описание готовилось для версии 9i]<BR><BR> Насколько я понимаю, эти ожидания прямых чтений в обычном случае dedicated сервера - в первую очередь операции сортировки,
 соединений и т.п. Различные загрузки SQL Loader'ом и т.п. тоже будут относиться сюда же, но они есть далеко не всегда</P>
<P>события 'direct path read' и 'direct path read (lob)' характеризуются прямым чтением пользовательским процессом данных в PGA, минуя SGA. Если система не поддерживает
 асинхронный ввод/ывод, каждое новое ожидание соответствует новому запросу ввода/вывода. Иначе при каждом обращении к блоку, еще не прочитанному в буфер, возникает запрос
 на чтение и обновляется статистика событий ожидания. Однако, в отличие от scattered и sequental read, количество событий ожидания может быть не равно количеству запросов
 на чтение. Параметры V\$SESSION_WAIT являются P1 - абсолютный номер файла, P2 - номер блока, P3 - количество блоков. Причины возникновения событий - сортировки не помещаются
 в памяти и уходят на диск (потом забираются пользователем через direct read), для сканирования используются параллельные дочки, серверный процесс обрабатывает буфера быстрее,
 чем подсистема ввода вывода возвращает буфера (сигнал о перегрузке I/O подсистемы). Это довольно ожидаемо для warehouse, но для DSS требует расследования</P>
<P>Для дисковых сортировок можно вычислить породившие сортировку запросы в V\$TEMPSEG_USAGE, и размер сортировки в V\$SESSTAT, далее можно уменьшить сортировку тюнингом SQL.
 Если WORKAREA_SIZE_POLICY = MANUAL, можно вручную увеличить SORT_AREA_SIZE, для автоматического режима нужно увеличивать PGA_AGGREGATE_TARGET. Для table full scan возможны
 искажения оптимизатора при большом коэффициенте параллелизма таблицы, необходимо проверить, что чтение производится корректно (?). Для запросов с hash join чрезмерный
 ввод/вывод возможен при малом размере HASH_AREA_SIZE, который имеет смысл увеличить (для автоматического режима нужно увеличивать PGA_AGGREGATE_TARGET</P>" ;

$event_desc{'direct_path_read_(lob)'} = "Событие ожидания <B>direct path read (lob)</B>
<P>[описание готовилось для версии 9i]<BR><BR> Насколько я понимаю, эти ожидания прямых чтений в обычном случае dedicated сервера - в первую очередь операции сортировки,
 соединений и т.п. Различные загрузки SQL Loader'ом и т.п. тоже будут относиться сюда же, но они есть далеко не всегда</P>
<P>события 'direct path read' и 'direct path read (lob)' характеризуются прямым чтением пользовательским процессом данных в PGA, минуя SGA. Если система не поддерживает
 асинхронный ввод/ывод, каждое новое ожидание соответствует новому запросу ввода/вывода. Иначе при каждом обращении к блоку, еще не прочитанному в буфер, возникает запрос
 на чтение и обновляется статистика событий ожидания. Однако, в отличие от scattered и sequental read, количество событий ожидания может быть не равно количеству запросов
 на чтение. Параметры V\$SESSION_WAIT являются P1 - абсолютный номер файла, P2 - номер блока, P3 - количество блоков. Причины возникновения событий - сортировки не помещаются
 в памяти и уходят на диск (потом забираются пользователем через direct read), для сканирования используются параллельные дочки, серверный процесс обрабатывает буфера быстрее,
 чем подсистема ввода вывода возвращает буфера (сигнал о перегрузке I/O подсистемы). Это довольно ожидаемо для warehouse, но для DSS требует расследования</P>
<P>Для дисковых сортировок можно вычислить породившие сортировку запросы в V\$TEMPSEG_USAGE, и размер сортировки в V\$SESSTAT, далее можно уменьшить сортировку тюнингом SQL.
 Если WORKAREA_SIZE_POLICY = MANUAL, можно вручную увеличить SORT_AREA_SIZE, для автоматического режима нужно увеличивать PGA_AGGREGATE_TARGET. Для table full scan возможны
 искажения оптимизатора при большом коэффициенте параллелизма таблицы, необходимо проверить, что чтение производится корректно (?). Для запросов с hash join чрезмерный
 ввод/вывод возможен при малом размере HASH_AREA_SIZE, который имеет смысл увеличить (для автоматического режима нужно увеличивать PGA_AGGREGATE_TARGET</P>" ;

$event_desc{'direct_path_write'} = "Событие ожидания <B>direct path write</B>
<P>[описание готовилось для версии 9i]<BR><BR> Отражает ожидания при прямой записи из PGA минуя DBWR (запись сортировок на диск, параллельные DML операции, прямые
 (direct-path) вставки и параллельные create table as select, а также некоторые LOB операции. Как и для direct path read при работе ФС в асинхронном режиме количество ожиданий
 не равняется количеству запросов на запись. Сессии ждут, когда все буфера PGA обработаны и нельзя продолжать выполнение до завершения операций ввода/вывода</P>
<P>Параметры V\$SESSION_WAIT - P1 (файл для записи), P2 (стартовый блок для записи), P3 (количество записываемых блоков). Причины возникновения - сортировки не помещаются
 в память или для создания и наполнения объектов используются параллельные операции. Для больших сотрировок можно вычислить породившие сортировку запросы в V\$TEMPSEG_USAGE,
 и размер сортировки в V\$SESSTAT, далее можно уменьшить сортировку тюнингов SQL. Если WORKAREA_SIZE_POLICY = MANUAL, можно вручную увеличить SORT_AREA_SIZE, для
 автоматического режима нужно увеличивать PGA_AGGREGATE_TARGET</P>
<P>Для параллельных DML операций нужно проверить распределение данных по дискам и выверить разметку (sizing) ФС на соответствие коэффициенту паралеллизма</P>" ;

# ================================================================================================
# ввод/вывод из данных в SGA
# ================================================================================================
$event_desc{'db_file_sequential_read'} = "Событие ожидания <B>db file sequential read</B>
<P>[описание готовилось для версии 9i]<BR><BR> Относится к вводу/выводу и отражает ожидания последовательного чтения, характерные для доступа к данным по индексам. Вполне
 ожидаемое и штатное событие - система ждёт окончания операций ввода/вывода</P>
<P>Это событие подразумевает, что пользовательский процесс производит чтение в буффер, и в процессе ожидает I/O операций. От предыдущего отличается тем, что чтение в
 последовательную область и, обычно это одноблоковое чтение. Обычно это результат использования индексов, редко full scan усекается до одного блока</P>
<P>Параметрами события в V\$SESSION_WAIT являются P1 - абсолютный номер файла, P2 - номер блока, P3 - количество блоков. На здоровой системе события вполне ожидаемы после
 ожиданий простоя (idle), однако появление db file sequential read свидетельствует о необходимости предпочтительного использования на больших warehouse операций полного
 сканирования таблиц в параллельном режиме</P>" ;

$event_desc{'db_file_scattered_read'} = "Событие ожидания <B>db file scattered read</B>
<P>[описание готовилось для версии 9i]<BR><BR> Это событие \"случайное чтение\" отражает ввод/вывод при full-scan доступе к таблицам данных, и может быть вполне ожидаемым.
 Однако если длительность события велика, имеет смысл посмотреть в сторону оптимизации доступа к данным, например введением фильтров, созданием индексов и т.п.</P>
<P>Cобытие подразумевает, что пользовательский процесс производит чтение в буффер, и в процессе ожидает I/O операций. Обычно это чтение в несвязанные разделы буфера, обычно
 это чтение multiblock, оно может подразумевать fast-scan операции, а не только полное сканирование таблицы</P>
<P>Параметрами V\$SESSION_WAIT являются P1 - абсолютный номер файла, P2 - номер блока, P3 - количество блоков</P>
<P>На здоровой системе вполне ожидаемы после ожиданий простоя (idle), однако появление ожиданий прямого чтения (direct read подразумевает full scan в параллельным запросом) и
 db file scattered read говорят о недостаточности доступа по индексам. Дополнительные симптомы - низкий коэффициент попадания в кэш и большое время на события ожидания для
 пользователей с проблемным временем отклика. Это ситуация чрезмерного ввода/вывода, для ее разрешения необходимо снизить I/O тюнингом запросов, конфигурированием workarea,
 добавлением дисков или разнесением данных на разные диски</P>
<P>Для начала необходимо пробовать тюнить SQL, для чего нужно найти запросы как по событиям ожидания сессий, как и по размеру физического ввода/вывода в V\$SQLAREA. Причинами
 могут быть плохо оптимизированный SQL, неиспользование индексов, высокопараллельный запрос или недостаточно аккуратная статистика оптимизатора. Также возможно некорректное
  распределение денных по дискам, что выявляется аналитикой нагрузки на диски. Ниже примеры вычисления SQL и сегментов, порождающих событие:</P>
<PRE>SELECT s.sql_address, s.sql_hash_value FROM V\$SESSION s, V\$SESSION_WAIT w
       WHERE w.event LIKE 'db file%read' AND w.sid = s.sid ;
SELECT segment_owner, segment_name FROM DBA_EXTENTS
       WHERE file_id = &p1 AND &p2 between block_id AND block_id + blocks - 1 ;
</PRE>" ;

# ================================================================================================
# очереди
# ================================================================================================
$event_desc{enqueue} = "Событие ожидания <B>enqueue</B>
<P>[описание готовилось для версии 9i]<BR><BR> Блокируют серийный доступ к ресурсам БД. Это событие показывает, что сессия ожидает снятия блокировки, подвешенной другой
 сессией. Параметрами V\$SESSION_WAIT являются P1 (тип блокировки, то же в 'V\$LOCK.TYPE = chr(bitand(P1,-16777216) / 16777215) || chr(bitand(P1,16711680) / 65535))', для
 запроса блокировки вычисляется как request = mod(P1, 65536)), P2 (то же, что и V\$LOCK.ID1), P3 (V\$LOCK.ID2). Сессии, держащие (hold) блокировки, можно получить из
 представления V\$LOCK, как и ожидающие (для этих поле REQUEST != 0)</P>
<PRE># отразить ждущие освобождения блокировки
SELECT * FROM V$LOCK WHERE request > 0 ;
# отразить блокирующие, для которых есть ждущие
SELECT DECODE(request,0,'Holder: ','Waiter: ')|| sid sess, id1, id2, lmode,request, type
       FROM V\$LOCK
       WHERE (id1, id2, type) IN (SELECT id1, id2, type FROM V\$LOCK WHERE request>0)
       ORDER BY id1, request;
</PRE>                                                                     
<P>Реакция зависит от типа блокировки</P>
<UL>
<LI>ST enqueue - блокировка возникает только для управляемых словарем бабличних пространств при задержке автоматического выделения места. Для временных табличных пространств
 нужно убедиться в использовании TEMPFILES. Для динамически растущих сегментов оптимально перейти на LMT, при невозможности - увеличит размер next_extent для избегания
 постоянного выделения места, или же предварительно выделить место для сегмента командой ALTER TABLE ALLOCATE EXTENT
<LI>HW enqueue - блокировка гарантирует последовательное выделение места за пределами HIGH WATER MARK сегмента. Параметры позволяют вычислить табличное пространство
 (V\$SESSION_WAIT.P2 / V\$LOCK.ID1) и заголовок увеличиваемого сегмента (V\$SESSION_WAIT.P2 / V\$LOCK.ID2). Решением является ручное довыделение места</LI>
<LI>TM enqueue - эта стек DML блокировок, чаще всего событие ожидания возникает при отсутствии издекса для поля внешнего ключа, и создание индекса позволяет избегать такого
 события ожидания</LI>
<LI>TX enqueue - эксклюзивная блокировка с начала первого изменения транзакции до операций COMMIT или ROLLBACK. Mode 6 возникает при ожидании строки, занятой другой сессией
 и разрешается командами COMMIT/ROLLBACK в удерживаеющей сессии. Mode 4 есть ьожидание ITL block, возникает при попытке заблокировать строку в блоке, в котором находятся
 другие заблокированные строки и свободных транзакционных слотов нет, решается увеличением количества транзакционных слотов (ITL, параметры INITTRANS или MAXTRANS для
 таблицы). Также возникает при ожидании сессией возможных задваиваний значения в уникальном индексе, когда при попытке записи одного значения двумя сессиями вторая ждет,
 возбуждать или не ORA-0001, решается COMMIT/ROLLBACK первой сессии. Также возникает пр ожидании фрагмента bitmap индекса, когда несколько сессий меняют строки, покрываемые
 одним фрагментом bitmap индекса, решение то же - COMMIT/ROLLBACK в первой сессии. Также возникает при ожидании PREPARED транзакции</LI>
</UL>
</P>" ;

# ================================================================================================
# защёлки
# ================================================================================================
$event_desc{latch_free} = "Событие ожидания <B>latch free</B>
<P>[описание готовилось для версии 9i]<BR><BR> Защёлки являются низкоуровневыми внутренними блокировками для защиты структур памяти, аналогичными блокировкам на прикладном 
уровне. Использование защёлки обычно идёт по пути - попытка вбить костыль (pins), при удаче - 'взведение' защёлки (latch), а при неудаче - ожидание. Счетчик события
 обновляется, когда при попытке получения защелки (latch) она не отдаёся с первого раза. Обращать внимание стоит, если время ожидания по событию составляет большую часть
  общего времени ожидания для системы или пользователя</P>
<P>Для определения причины нужно идентифицировать защёлку (их много видов под разные задачи), анализировать смежные ресурсы (например для нагрузки на защёлки библиотечного
 кэша полезно проанализировать показатели полных и неполных запросов), проанализировать запросы проблемных сессий</P>
<P>Параметры V\$SESSION_WAIT - P1 (адрес защёлки), P2 (номер защелки), P3 (время ожидания процессом защёлки)</P>
<PRE>
# текущие ожидания защёлок
SELECT n.name, SUM(w.p3) Sleeps FROM V\$SESSION_WAIT w, V\$LATCHNAME n
       WHERE w.event = 'latch free' AND w.p2 = n.latch# GROUP BY n.name ;
</PRE>
<TABLE BORDER=\"1\">
<TR><TD>Защёлка</TD><TD>Область SGA</TD><TD>Возможные причины</TD><TD>Куда смотреть</TD></TR>
<TR><TD>Shared pool, library cache</TD>
    <TD>Shared pool</TD>
    <TD>Запросы не используются повторно, не используются связанные переменные, недостаточен размер кэша приложения, курсор явно закрывается после каждого выполнения, частый
        login/logout, базовые структуры объекта модифицированы (например очищены), shared pool слишком мал</TD>
    <TD>в V\$SESSTAT высоки: parse time CPU, parse time elapsed, parse count (hard) / execute count, parse count (total) / execute count. Курсоры в V\$SQLAREA/V$SQL отражают
        высокий коэффициент PARSE_CALLS / EXECUTIONS, EXECUTIONS = 1 отличаются только литералами в классе WHERE, высоки значения RELOADS и/или INVALIDATIONS, большой (> 1mb)
        SHARABLE_MEM</TD></TR>
<TR><TD>cache buffers lru chain</TD>
    <TD>Buffer cache LRU lists</TD>
    <TD>Чрезмерный обмен кеша буферов (например неэффективный SQL производит множественные full scan или итерации по неэфективным большим индексам), слишком маленький кэш,
        DBRW не успевает отписывать загрязненные буфера, что удлиняет ожидание защёлки при поиске свободных буферов</TD>
    <TD>SQL предложения с большим логическим или физическим вводом/выводом или используются неселективные индексы</TD></TR>
<TR><TD>cache buffers chains</TD>
    <TD>Buffer cache buffers</TD>
    <TD>Повторяющийся доступ к блоку (или малое количество блоков), называемое 'горячим блоком'</TD>
    <TD>Свой код вычисления номера последовательности на основе update строки вместо использования штатного генератора номера последовательности, индексный лист утилизируется
        большим количеством процессов сканирования некоторого неселективного индекса с простым предикатом, нужно идентифицировать 'горячий блок'</TD></TR>
</TABLE>

<P>Обычно проблемы с защелками shared pool или библиотечного кэша связаны с парсингом</P>
<PRE>
# сравнить вручную
SELECT sql_text FROM V\$SQLAREA WHERE executions < 4 ORDER BY sql_text;
      
# найти отличающиеся литералами полуавтоматом
SELECT SUBSTR(sql_text,1, 60), COUNT(*) FROM V\$SQLAREA
       WHERE executions < 4
       GROUP BY SUBSTR(sql_text, 1, 60)
       HAVING COUNT(*) > 1;
                                   
# поиск постоянно перепарсиваемых для тюнинга
# когда PARSE_CALLS стремится к EXECUTIONS
SELECT SQL_TEXT, PARSE_CALLS, EXECUTIONS
       FROM V\$SQLAREA
       ORDER BY PARSE_CALLS ;
                                             
# поиск сессий с постоянным перепарсиванием
SELECT pa.sid, pa.value \"Hard Parses\", ex.value \"Execute Count\"
       FROM v\$sesstat pa, v\$sesstat ex
       WHERE pa.sid=ex.sid 
             AND pa.statistic# = (select statistic# FROM v\$statname
                                         where name='parse count (hard)')
             AND ex.statistic# = (select statistic# FROM v\$statname
                                         where name='execute count')
             AND pa.value > 0 ;
</PRE>" ;

#$event_desc{} = "Событие ожидания <B></B><P></P>" ;
# 1 и строка в конце файла является необходимой для корректного включения конфигурационного файла
1

