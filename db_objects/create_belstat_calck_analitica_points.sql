--
-- ВНИМАНИМЕ Настоящая процедура является частью коммерческого программного продукта ОрСиМОН БЕССТ (С) Sergey S. Belonin Все права защищены.
-- Использование настоящего кода без заключения письменного лицензионного соглашения с правообладателем или правомочным сублицензиаром ЗАПРЕЩЕНО
-- ATTENTION This procedure are part of commercial software product OrSiMON BESST (C) Sergey S. Belonin All rights reserved
-- Before use this procedure you must sign license agreement with owner or sublicensear
--


CREATE OR REPLACE PROCEDURE CALCK_ANALITICA_POINTS (FROM_SNAP_ID INTEGER, TO_SNAP_ID INTEGER) AS
-- переменные для отображения утилизации CPU
CPU_USED_BTSES         INTEGER ;
PARSE_TIME_CPU         INTEGER ;
PARSE_TIME_ELAPSED     INTEGER ;
-- переменные для отображения обработок SQL
PARSE_COUNT_TOTAL      INTEGER ;
PARSE_COUNT_HARD       INTEGER ;
HIT_PARSE              INTEGER(6,2) ;
WAIT_PARSE_PERCENT     INTEGER(6,2) ;
-- переменные для отображения утилизации библиотечного кэша
LIBCACHE_DIFF_GETS     INTEGER ;
LIBCACHE_DIFF_GETHITS  INTEGER ;
LIBCACHE_GETHITRATIO   INTEGER(6,2) ;
LIBCACHE_DIFF_PINS     INTEGER ;
LIBCACHE_DIFF_PINHITS  INTEGER ;
LIBCACHE_PINHITRATIO   INTEGER(6,2) ;
LIBCACHE_DIFF_RELOADS  INTEGER ;
LIBCACHE_DIFF_INVALIDT INTEGER ;
-- переменные для отображения статистик по транзакциям
EXECUTE_COUNT          INTEGER ;
USER_CALLS             INTEGER ;
USER_COMMITS           INTEGER ;
USER_ROLLBACKS         INTEGER ;
SUM_TRANS_COUNT        INTEGER ;
SUM_UNDOBLOCKS         INTEGER ;
AVG_UNDOBLOCKS         INTEGER ;
MAX_UNDOBLOCKS         INTEGER ;
MAX_TRANS_TIMELEN      INTEGER ;
MAX_CONCURRENCY        INTEGER ;

-- переменные для отображения физических чтений и записей
PHYSICAL_READS         INTEGER ;
PHYSICAL_RD_DIRECT     INTEGER ;
PHYSICAL_RD_DIRLOB     INTEGER ;
PHYSCL_RD_INTO_BFCACHE INTEGER ;
PHYSICAL_WRITES        INTEGER ;
-- переменные для отображения логических чтений и записей
-- логических чтений неизменных (1) + с привлечением данных UNDO (2) = логических чтений (3)
DB_BLOCK_GETS          INTEGER ;
CONSISTENT_GETS        INTEGER ;
SESSION_LOGICAL_READS  INTEGER ;
CONSISTENT_GET_PERCENT INTEGER(6,2) ;
DB_BLOCK_CHANGES       INTEGER ;
-- переменные для отображения утилизации кеша буферов
DB_CACHE_HIT_RATIO     INTEGER(6,2) ;
CHECK_LOGICAL_READS    INTEGER ;
FREE_BUFFER_WAIT       INTEGER ;
WRITE_COMPLETE_WAIT    INTEGER ;
BUFFER_BUSY_WAIT       INTEGER ;
-- переменные для отображения утилизации буфера оперативных журналов
REDO_BUFF_ALLOC_ENTR   INTEGER ;
-- переменные для отображения утилизации оперативных журналов
REDO_SIZE              INTEGER ;
REDOLOG_AVG_PERMIN     INTEGER ;                                                                                                                                
REDOLOG_MAX_PERMIN     INTEGER ;                                                                                                                                
-- переменные для отображения утилизации архивных журналов
ARCHIVE_LOG_SIZE       INTEGER ;
-- переменные для отображения свободной памяти в shared pool
FREEMEM_SHPL_START     INTEGER ;
FREEMEM_SHPL_END       INTEGER ;
-- переменные для отображения параметров резервного пула
SHPOOL_REQUEST_MISSES  INTEGER ;
SHPOOL_REQUEST_FAIL    INTEGER ;
-- переменные для отображения утилизации кэша словаря
DIC_DIFF_GETS          INTEGER ;
DIC_DIFF_GETMISSES     INTEGER ;
DIC_DIFF_MODIFICATIONS INTEGER ;
DIC_DIFF_FLUSHES       INTEGER ;
-- переменные для отображения утилизации PGA
SORTS_MEMORY           INTEGER ;
SORTS_DISK             INTEGER ;
WEIGTH_DISKS           INTEGER(6,2) ;
SORTS_OPTIMAL          INTEGER ;
SORTS_ONEPASS          INTEGER ;
WEIGTH_ONEPASS         INTEGER(6,2) ;
SORTS_MULTIPASS        INTEGER ;
WEIGTH_MULTIPASS       INTEGER(6,2) ;
-- переменные для отображения утилизации сетевого трафика
BYTES_RECV_SQLNET_CL   INTEGER ;
BYTES_SENT_SQLNET_CL   INTEGER ;
-- переменные для отображения дополнительных статистик
PERIOD                 INTEGER ;
LOGONS                 INTEGER ;

V_TMP1                 INTEGER ;
v_code                 INTEGER ;
v_errm		       VARCHAR2(62) ;
 

BEGIN

-- процедура заполнения таблицы основных аналитических показателей
   FOR res IN ( SELECT POINT_ID,SNAP_LEVEL,CR_SNAP_ID,CR_SNAP_TIME,PR_SNAP_ID,PR_SNAP_TIME
                       FROM CLC_DELTA_SYSSTAT
                       WHERE POINT_ID = 0 AND CR_SNAP_ID > FROM_SNAP_ID AND CR_SNAP_ID <= TO_SNAP_ID
                       GROUP BY POINT_ID,SNAP_LEVEL,CR_SNAP_ID,CR_SNAP_TIME,PR_SNAP_ID,PR_SNAP_TIME ORDER BY CR_SNAP_ID) LOOP

       BEGIN
-- занулить все показатели
CPU_USED_BTSES := 0 ; PARSE_TIME_CPU := 0 ;
PARSE_TIME_ELAPSED := 0 ; PARSE_COUNT_TOTAL := 0 ; PARSE_COUNT_HARD := 0 ; LIBCACHE_DIFF_GETS := 0 ; LIBCACHE_DIFF_GETHITS := 0 ; LIBCACHE_DIFF_PINS := 0 ;
LIBCACHE_DIFF_PINHITS := 0 ; LIBCACHE_DIFF_RELOADS := 0 ; LIBCACHE_DIFF_INVALIDT := 0 ; EXECUTE_COUNT := 0 ; USER_CALLS := 0 ; USER_COMMITS := 0 ;
USER_ROLLBACKS := 0 ; SUM_TRANS_COUNT := 0 ; SUM_UNDOBLOCKS := 0 ; AVG_UNDOBLOCKS := 0 ; MAX_UNDOBLOCKS := 0 ; MAX_TRANS_TIMELEN := 0 ;
MAX_CONCURRENCY := 0 ; PHYSICAL_READS := 0 ; PHYSICAL_RD_DIRECT := 0 ; PHYSICAL_RD_DIRLOB := 0 ; PHYSCL_RD_INTO_BFCACHE := 0 ; PHYSICAL_WRITES := 0 ;
DB_BLOCK_GETS := 0 ; CONSISTENT_GETS := 0 ; SESSION_LOGICAL_READS := 0 ; DB_BLOCK_CHANGES := 0 ; FREE_BUFFER_WAIT := 0 ; WRITE_COMPLETE_WAIT := 0 ;
BUFFER_BUSY_WAIT := 0 ; REDO_BUFF_ALLOC_ENTR := 0 ; REDO_SIZE := 0 ; REDOLOG_AVG_PERMIN := 0 ; REDOLOG_MAX_PERMIN := 0 ; ARCHIVE_LOG_SIZE := 0 ;
FREEMEM_SHPL_START := 0 ; FREEMEM_SHPL_END := 0 ; SHPOOL_REQUEST_MISSES := 0 ; SHPOOL_REQUEST_FAIL := 0 ; DIC_DIFF_GETS := 0 ; DIC_DIFF_GETMISSES := 0 ;
DIC_DIFF_MODIFICATIONS := 0 ; DIC_DIFF_FLUSHES := 0 ; SORTS_MEMORY := 0 ; SORTS_DISK := 0 ; SORTS_OPTIMAL := 0 ; SORTS_ONEPASS := 0 ;
SORTS_MULTIPASS := 0 ; BYTES_RECV_SQLNET_CL := 0 ; BYTES_SENT_SQLNET_CL := 0 ; PERIOD := 0 ; LOGONS := 0 ;
-- идентифицирующие показатели берутся из курсора управления циклом
--
-- показатели утилизации CPU
          SELECT SS.DIFFERENCE INTO CPU_USED_BTSES        FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'CPU used by this session' ;
          SELECT SS.DIFFERENCE INTO PARSE_TIME_CPU        FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'parse time cpu' ;
          SELECT SS.DIFFERENCE INTO PARSE_TIME_ELAPSED    FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'parse time elapsed' ;
-- показатели обработок SQL
          SELECT SS.DIFFERENCE INTO PARSE_COUNT_TOTAL     FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'parse count (total)' ;
          SELECT SS.DIFFERENCE INTO PARSE_COUNT_HARD      FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'parse count (hard)' ;
          HIT_PARSE := ( PARSE_COUNT_TOTAL - PARSE_COUNT_HARD ) * 100 / ( PARSE_COUNT_TOTAL + 1 ) ;
          IF ( PARSE_TIME_ELAPSED > 0 ) THEN
             WAIT_PARSE_PERCENT := ( PARSE_TIME_ELAPSED - PARSE_TIME_CPU ) * 100 / ( PARSE_TIME_ELAPSED ) ;
          ELSE WAIT_PARSE_PERCENT := 0 ; END IF ;
          IF WAIT_PARSE_PERCENT < 0 THEN WAIT_PARSE_PERCENT := 0 ; END IF ;
-- показатели библиотечного кэша
          SELECT SUM(DIFF_GETS),SUM(DIFF_GETHITS), CASE WHEN SUM(DIFF_GETS) > 0 THEN SUM(DIFF_GETHITS) * 100 / SUM(DIFF_GETS) ELSE 0 END, 
                 SUM(DIFF_PINS),SUM(DIFF_PINHITS), CASE WHEN SUM(DIFF_PINS) > 0 THEN SUM(DIFF_PINHITS) * 100 / SUM(DIFF_PINS) ELSE 0 END, 
                 SUM(DIFF_RELOADS),SUM(DIFF_INVALIDATIONS) 
                 INTO LIBCACHE_DIFF_GETS, LIBCACHE_DIFF_GETHITS, LIBCACHE_GETHITRATIO, LIBCACHE_DIFF_PINS, LIBCACHE_DIFF_PINHITS, LIBCACHE_PINHITRATIO,
                      LIBCACHE_DIFF_RELOADS, LIBCACHE_DIFF_INVALIDT
                 FROM CLC_DELTA_LIBRARYCACHE 
                 WHERE CR_SNAP_ID = res.CR_SNAP_ID 
                 GROUP BY CR_SNAP_ID ;
                 
-- показатели транзакций и UNDO
          SELECT SS.DIFFERENCE INTO USER_CALLS            FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'user calls' ;
          SELECT SS.DIFFERENCE INTO USER_COMMITS          FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'user commits' ;
          SELECT SS.DIFFERENCE INTO USER_ROLLBACKS        FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'user rollbacks' ;
          SELECT SS.DIFFERENCE INTO EXECUTE_COUNT         FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'execute count' ;
          SELECT SUM(TXNCOUNT), SUM(BLOCKS), AVG(SPEED), MAX(SPEED), MAX(MAXQUERYLEN), MAX(MAXCONCURRENCY)
                 INTO SUM_TRANS_COUNT, SUM_UNDOBLOCKS, AVG_UNDOBLOCKS, MAX_UNDOBLOCKS, MAX_TRANS_TIMELEN, MAX_CONCURRENCY
                 FROM ( SELECT SUM(UNDOBLKS) BLOCKS, CASE WHEN (END_TIME - BEGIN_TIME) > 0  THEN SUM(UNDOBLKS) / ((END_TIME - BEGIN_TIME)*1440) ELSE 0 END SPEED,
                               SUM(TXNCOUNT) TXNCOUNT, MAX(MAXQUERYLEN) MAXQUERYLEN, MAX(MAXCONCURRENCY) MAXCONCURRENCY
                               FROM CLC_UNDOSTAT 
                               WHERE END_TIME > res.PR_SNAP_TIME AND END_TIME <= res.CR_SNAP_TIME
                               GROUP BY BEGIN_TIME, END_TIME ) ;
-- показатели физического ввода/вывода
          SELECT SS.DIFFERENCE INTO PHYSICAL_READS        FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'physical reads' ;
          SELECT SS.DIFFERENCE INTO PHYSICAL_RD_DIRECT    FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'physical reads direct' ;
          SELECT SS.DIFFERENCE INTO PHYSICAL_RD_DIRLOB    FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'physical reads direct (lob)' ;
          PHYSCL_RD_INTO_BFCACHE := PHYSICAL_READS - PHYSICAL_RD_DIRECT - PHYSICAL_RD_DIRLOB ;
          SELECT SS.DIFFERENCE INTO PHYSICAL_WRITES       FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'physical writes' ;
-- показатели логического ввода/вывода
          SELECT SS.DIFFERENCE INTO DB_BLOCK_GETS         FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'db block gets' ;
          SELECT SS.DIFFERENCE INTO CONSISTENT_GETS       FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'consistent gets' ;
          SELECT SS.DIFFERENCE INTO SESSION_LOGICAL_READS FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'session logical reads' ;
-- не в таблицу
          CONSISTENT_GET_PERCENT := CONSISTENT_GETS * 100 / ( DB_BLOCK_GETS + CONSISTENT_GETS + 1) ;
          SELECT SS.DIFFERENCE INTO DB_BLOCK_CHANGES      FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'db block changes' ;
-- показатели кэша буферов
          DB_CACHE_HIT_RATIO  := (1 - ((PHYSICAL_READS - PHYSICAL_RD_DIRECT - PHYSICAL_RD_DIRLOB)/ (DB_BLOCK_GETS + CONSISTENT_GETS - PHYSICAL_RD_DIRECT - PHYSICAL_RD_DIRLOB + 1))) * 100 ;
          CHECK_LOGICAL_READS := DB_BLOCK_GETS + CONSISTENT_GETS ;
          SELECT DIFF_FREE_BUFFER_WAIT, DIFF_WRITE_COMPLETE_WAIT, DIFF_BUFFER_BUSY_WAIT 
                 INTO FREE_BUFFER_WAIT, WRITE_COMPLETE_WAIT, BUFFER_BUSY_WAIT
                 FROM CLC_DELTA_BUFF_POOL_STAT
                 WHERE CR_SNAP_ID = res.CR_SNAP_ID AND ROWNUM = 1 ;
-- показатели буфера оперативных журналов
          SELECT SS.DIFFERENCE INTO REDO_BUFF_ALLOC_ENTR  FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'redo buffer allocation retries' ;
-- показатели оперативных журналов 
-- показатели архивных журналов
          SELECT SS.DIFFERENCE INTO REDO_SIZE             FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'redo size' ;

          SELECT SUM(BLOCKS), AVG(SPEED), MAX(SPEED) INTO REDOLOG_AVG_PERMIN, REDOLOG_MAX_PERMIN, ARCHIVE_LOG_SIZE
                 FROM ( SELECT THREAD#, SEQUENCE#, SUM(BLOCKS*BLOCK_SIZE)/COUNT(DEST_ID) BLOCKS, 
                               CASE WHEN (NEXT_TIME - FIRST_TIME) > 0 THEN (NEXT_TIME - FIRST_TIME) * 1440 ELSE 0 END TIMELEN, 
                               CASE WHEN (NEXT_TIME - FIRST_TIME) > 0 THEN (SUM(BLOCKS*BLOCK_SIZE)/COUNT(DEST_ID))/((NEXT_TIME - FIRST_TIME) * 1440)
                                    ELSE 0 END SPEED
                               FROM CLC_ARCHIVED_LOG 
                               WHERE NEXT_TIME > res.PR_SNAP_TIME AND NEXT_TIME <= res.CR_SNAP_TIME
                               GROUP BY THREAD#, SEQUENCE#, NEXT_TIME, FIRST_TIME 
                               ORDER BY SEQUENCE# ) ;
-- показатели свободной памяти в shared pool
          SELECT PR_BYTES, CR_BYTES INTO FREEMEM_SHPL_START, FREEMEM_SHPL_END
                 FROM CLC_DELTA_SGASTAT 
                 WHERE CR_SNAP_ID = res.CR_SNAP_ID AND ROWNUM = 1 ;
-- показатели параметров резервного пула
-- в связи с тем, что обработка представления V$SHARED_POOL_RESERVED не реализована
          SHPOOL_REQUEST_MISSES := 0 ;
          SHPOOL_REQUEST_FAIL   := 0 ;
-- показатели кэша словаря
          SELECT SUM(DIFF_GETS),SUM(DIFF_GETMISSES),SUM(DIFF_MODIFICATIONS),SUM(DIFF_FLUSHES)
                 INTO DIC_DIFF_GETS, DIC_DIFF_GETMISSES, DIC_DIFF_MODIFICATIONS, DIC_DIFF_FLUSHES 
                 FROM CLC_DELTA_ROWCACHE
                 WHERE CR_SNAP_ID = res.CR_SNAP_ID AND ROWNUM = 1 ;
-- переменные для отображения утилизации PGA
          SELECT SS.DIFFERENCE INTO SORTS_MEMORY          FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'sorts (memory)' ;
          SELECT SS.DIFFERENCE INTO SORTS_DISK            FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'sorts (disk)' ;
-- исключает деление на ноль и не влияет на статистику в боевых системах
          WEIGTH_DISKS := SORTS_DISK * 100 / ( SORTS_MEMORY + SORTS_DISK + 1 ) ;
-- в связи с тем, что обработка  V$SQL_WORKAREA_HISTOGRAM коллектором ещё не реализована
          SORTS_OPTIMAL    := 0 ;
          SORTS_ONEPASS    := 0 ;
          WEIGTH_ONEPASS   := 0 ;
          SORTS_MULTIPASS  := 0 ;
          WEIGTH_MULTIPASS := 0 ;
-- показатели сетевого трафика
          SELECT SS.DIFFERENCE INTO BYTES_RECV_SQLNET_CL  FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'bytes received via SQL*Net from client' ;
          SELECT SS.DIFFERENCE INTO BYTES_SENT_SQLNET_CL  FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'bytes sent via SQL*Net to client' ;
-- переменные для отображения дополнительных статистик
          PERIOD := ((res.CR_SNAP_TIME - res.PR_SNAP_TIME) * 24 * 60 * 60 * 1000000) ; 
          SELECT SS.DIFFERENCE INTO LOGONS                FROM CLC_DELTA_SYSSTAT SS, V$STATNAME SN WHERE SS.POINT_ID = res.POINT_ID AND SS.CR_SNAP_ID = res.CR_SNAP_ID AND SS.STATISTIC# = SN.STATISTIC# AND ROWNUM = 1 AND SN.NAME = 'logons cumulative' ;

INSERT INTO CLC_ANALITICA_POINTS (POINT_ID,SNAP_LEVEL,CR_SNAP_ID,CR_SNAP_TIME,PR_SNAP_ID,PR_SNAP_TIME,CPU_USED_BTSES,PARSE_TIME_CPU,PARSE_TIME_ELAPSED,
       PARSE_COUNT_TOTAL,PARSE_COUNT_HARD,LIBCACHE_DIFF_GETS,LIBCACHE_DIFF_GETHITS,LIBCACHE_DIFF_PINS,LIBCACHE_DIFF_PINHITS,LIBCACHE_DIFF_RELOADS,
       LIBCACHE_DIFF_INVALIDT,EXECUTE_COUNT,USER_CALLS,USER_COMMITS,USER_ROLLBACKS,SUM_TRANS_COUNT,SUM_UNDOBLOCKS,AVG_UNDOBLOCKS,MAX_UNDOBLOCKS,
       MAX_TRANS_TIMELEN,MAX_CONCURRENCY,PHYSICAL_READS,PHYSICAL_RD_DIRECT,PHYSICAL_RD_DIRLOB,PHYSCL_RD_INTO_BFCACHE,PHYSICAL_WRITES,DB_BLOCK_GETS,
       CONSISTENT_GETS,SESSION_LOGICAL_READS,DB_BLOCK_CHANGES,FREE_BUFFER_WAIT,WRITE_COMPLETE_WAIT,BUFFER_BUSY_WAIT,REDO_BUFF_ALLOC_ENTR,REDO_SIZE,
       REDOLOG_AVG_PERMIN,REDOLOG_MAX_PERMIN,ARCHIVE_LOG_SIZE,FREEMEM_SHPL_START,FREEMEM_SHPL_END,SHPOOL_REQUEST_MISSES,SHPOOL_REQUEST_FAIL,DIC_DIFF_GETS,
       DIC_DIFF_GETMISSES,DIC_DIFF_MODIFICATIONS,DIC_DIFF_FLUSHES,SORTS_MEMORY,SORTS_DISK,SORTS_OPTIMAL,SORTS_ONEPASS,SORTS_MULTIPASS,GET_FROM_SQLNET,
       SEND_TO_SQLNET,PERIOD,LOGONS)
       VALUES(res.POINT_ID,res.SNAP_LEVEL,res.CR_SNAP_ID,res.CR_SNAP_TIME,res.PR_SNAP_ID,res.PR_SNAP_TIME,CPU_USED_BTSES,PARSE_TIME_CPU,PARSE_TIME_ELAPSED,
       PARSE_COUNT_TOTAL,PARSE_COUNT_HARD,LIBCACHE_DIFF_GETS,LIBCACHE_DIFF_GETHITS,LIBCACHE_DIFF_PINS,LIBCACHE_DIFF_PINHITS,LIBCACHE_DIFF_RELOADS,
       LIBCACHE_DIFF_INVALIDT,EXECUTE_COUNT,USER_CALLS,USER_COMMITS,USER_ROLLBACKS,SUM_TRANS_COUNT,SUM_UNDOBLOCKS,AVG_UNDOBLOCKS,MAX_UNDOBLOCKS,
       MAX_TRANS_TIMELEN,MAX_CONCURRENCY,PHYSICAL_READS,PHYSICAL_RD_DIRECT,PHYSICAL_RD_DIRLOB,PHYSCL_RD_INTO_BFCACHE,PHYSICAL_WRITES,DB_BLOCK_GETS,
       CONSISTENT_GETS,SESSION_LOGICAL_READS,DB_BLOCK_CHANGES,FREE_BUFFER_WAIT,WRITE_COMPLETE_WAIT,BUFFER_BUSY_WAIT,REDO_BUFF_ALLOC_ENTR,REDO_SIZE,
       REDOLOG_AVG_PERMIN,REDOLOG_MAX_PERMIN,ARCHIVE_LOG_SIZE,FREEMEM_SHPL_START,FREEMEM_SHPL_END,SHPOOL_REQUEST_MISSES,SHPOOL_REQUEST_FAIL,DIC_DIFF_GETS,
       DIC_DIFF_GETMISSES,DIC_DIFF_MODIFICATIONS,DIC_DIFF_FLUSHES,SORTS_MEMORY,SORTS_DISK,SORTS_OPTIMAL,SORTS_ONEPASS,SORTS_MULTIPASS,BYTES_RECV_SQLNET_CL,
       BYTES_SENT_SQLNET_CL,PERIOD,LOGONS) ;
       COMMIT ;
       EXCEPTION WHEN OTHERS THEN
                 v_code := SQLCODE;
                 v_errm := SUBSTR(SQLERRM, 1, 64);
                 DBMS_OUTPUT.PUT_LINE('Exception on current point ID = '||res.CR_SNAP_ID||' Error code ' || v_code || ': ' || v_errm) ;
          NULL ;
       END ;

   END LOOP ;
END CALCK_ANALITICA_POINTS ;
/

show errors ;

spool /tmp/aaaha ;
set serveroutput on  pagesize 4000 linesize 300
exec DBMS_OUTPUT.ENABLE(2000000) ;
delete from CLC_ANALITICA_POINTS ;
commit ;
exec CALCK_ANALITICA_POINTS(0,50000) ;
-- 
select count(*) from CLC_ANALITICA_POINTS ;
spool off ;
exit ;

--
-- ВНИМАНИМЕ Настоящая процедура является частью коммерческого программного продукта ОрСиМОН БЕССТ (С) Sergey S. Belonin Все права защищены.
-- Использование настоящего кода без заключения письменного лицензионного соглашения с правообладателем или правомочным сублицензиаром ЗАПРЕЩЕНО
-- ATTENTION This procedure are part of commercial software product OrSiMON BESST (C) Sergey S. Belonin All rights reserved
-- Before use this procedure you must sign license agreement with owner or sublicensear
--
